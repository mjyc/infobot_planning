#!/usr/bin/env python

import rospy

import actionlib
from dynamic_reconfigure.server import Server
from geometry_msgs.msg import Pose
from move_base_msgs.msg import *
from tf.transformations import quaternion_from_euler
from infobot_find_viewpoint.cfg import InfoBotFindViewpointNodeConfig
from infobot_find_viewpoint_msgs.msg import *
from infobot_find_viewpoint_msgs.srv import *
from infobot_map_msgs.srv import *
from infobot_topo_msgs.srv import *
from infobot_image_saver.srv import *


def call_srv(srv_name, srv_type, srv_args):
    rospy.wait_for_service(srv_name)
    try:
        srv_proxy = rospy.ServiceProxy(srv_name, srv_type)
        return srv_proxy(*srv_args)
    except rospy.ServiceException, e:
        rospy.logerr("Service call failed: %s" % e)
        return None


def publish_pmap_octomap(pmap_filename, octomap_fiilename):
    rospy.logwarn("IGNORES INPUT pmap_frame_id. Uses \"map\" instead.")
    publish_pmap_resp = call_srv("publish_pmap", PublishProbabilityMap, (pmap_filename, ""))
    if not publish_pmap_resp or not publish_pmap_resp.success:
        return False
    rospy.logwarn("IGNORES INPUT octomap_frame_id. Uses \"map\" instead.")
    publish_octomap_resp = call_srv("publish_octomap", PublishOctomap, (octomap_fiilename, ""))
    if not publish_octomap_resp or not publish_octomap_resp.success:
        return False
    return True


def publish_pmap_octomap_topomap(pmap_filename, octomap_fiilename, topomap_filename):
    rospy.logwarn("IGNORES INPUT topomap_frame_id. Uses \"map\" instead.")
    publish_pmap_octomap(pmap_filename, octomap_fiilename)
    publish_topomap_resp = call_srv("publish_topomap", PublishTopologicalMap, (topomap_filename, ""))
    if not publish_topomap_resp or not publish_topomap_resp.success:
        return False
    return True


def call_compute_vis_value_srv(pose, mode):
    resp = call_srv("compute_vis_value", ComputeVisibilityValue, (
        pose,
        mode,
        "",  # use published pmap_filename
        "",  # use published pmap_frame
        "",  # use published octomap_filename
        ""   # use published octomap_frame
    ))
    return resp


def get_poses_from_topomap(topomap_fiilename, z):
    get_topomap_resp = call_srv("get_topomap", GetTopologicalMap, (topomap_fiilename, ""))
    if not get_topomap_resp:
        return []

    poses = []
    for place in get_topomap_resp.topomap.places:
        for view in place.views:
            pose = Pose()
            pose.position.x = view.pose.x
            pose.position.y = view.pose.y
            pose.position.z = z
            q = quaternion_from_euler(0, 0, view.pose.theta)
            pose.orientation.x = q[0]
            pose.orientation.y = q[1]
            pose.orientation.z = q[2]
            pose.orientation.w = q[3]
            poses.append(pose)

    return poses


def apply_pmap_bbx_filter(poses, pmap_filename, margin):
    '''
        margin: in meters
    '''
    get_pmap_resp = call_srv("get_pmap", GetProbabilityMap, (pmap_filename, ""))
    if not get_pmap_resp:
        return None

    minX = get_pmap_resp.pmap.info.origin.position.x - margin
    maxX = get_pmap_resp.pmap.info.origin.position.x + \
        (get_pmap_resp.pmap.info.width * get_pmap_resp.pmap.info.resolution) + margin
    minY = get_pmap_resp.pmap.info.origin.position.y - margin
    maxY = get_pmap_resp.pmap.info.origin.position.y + \
        (get_pmap_resp.pmap.info.height * get_pmap_resp.pmap.info.resolution) + margin

    new_poses = []
    for pose in poses:
        if pose.position.x > minX and pose.position.x < maxX and pose.position.y > minY and pose.position.y < maxY:
            new_poses.append(pose)

    return new_poses


def call_compute_vis_values_srv(poses, mode):
    resp = call_srv("compute_vis_values", ComputeVisibilityValues, (
        poses,
        mode,
        "",  # use published pmap_filename
        "",  # use published pmap_frame
        "",  # use published octomap_filename
        ""   # use published octomap_frame
    ))
    return resp


class FindViewpointNode(object):

    def __init__(self, name):
        self._action_name = name

        # calls self._reconfigure_callback!
        self._config_server = Server(InfoBotFindViewpointNodeConfig, self._reconfigure_callback)

        self._as = actionlib.SimpleActionServer(
            self._action_name, FindViewpointAction, execute_cb=self._execute_cb, auto_start=False)
        self._as.start()

        rospy.spin()  # for config server

    def _reconfigure_callback(self, config, level):
        self._camera_trans_z = config.camera_trans_z
        self._rect_filter_margin = config.rect_filter_margin
        self._max_iter = config.max_iter
        return config

    def _execute_cb(self, goal):

        feedback = FindViewpointFeedback()
        result = FindViewpointResult()
        result.img_saved = False

        abort = False
        preempt = False

        cur_poses = []

        # publish maps
        if not publish_pmap_octomap_topomap(goal.pmap_filename, goal.octomap_filename, goal.topomap_filename):
            rospy.logerr("%s: Error while publishing maps." % self._action_name)
            abort = True
        # process maps
        cur_poses = get_poses_from_topomap(goal.topomap_filename, self._camera_trans_z)
        cur_poses = apply_pmap_bbx_filter(cur_poses, goal.pmap_filename, self._rect_filter_margin)
        if cur_poses == []:
            rospy.logerr("%s: Error while extracting poses." % self._action_name)
            abort = True

        max_iter = rospy.get_param("~num_iter", FindViewpointNode.DEFAULT_NUM_ITER)
        cur_iter = 0
        prev_max_pose = None
        prev_real_vis_val = -1
        move_base_ac = actionlib.SimpleActionClient("move_base", MoveBaseAction)
        move_base_ac.wait_for_server()
        while cur_iter < self._max_iter and not abort and not preempt:
            rospy.loginfo("%s: Iter=%d" % (self._action_name, cur_iter))

            if self._as.is_preempt_requested():
                rospy.loginfo("%s: Preempted" % self._action_name)
                preempt = True
                break

            # check current vis_value
            compute_vis_val_resp = None
            if prev_max_pose is not None:
                compute_vis_val_resp = call_compute_vis_value_srv(prev_max_pose, goal.pmap_to_octomap_mode)
                if not compute_vis_val_resp:
                    rospy.logerr("%s: Error while calling compute_vis_val srv." % self._action_name)
                    abort = True
                    break
                cur_real_vis_val = compute_vis_val_resp.vis_value
                rospy.loginfo("%s: Current real vis_value = %f" % (self._action_name, cur_real_vis_val))
                if cur_real_vis_val > prev_real_vis_val:
                    prev_real_vis_val = cur_real_vis_val
                    rospy.loginfo("%s: New best viewpoint found." % self._action_name)
                    outimg_filename = goal.img_filename
                    if outimg_filename == "":
                        outimg_filename = "result.jpg"
                    save_image_resp = call_srv("save_image", SaveImage, [outimg_filename])
                    if not save_image_resp:
                        rospy.loginfo("if not save_image_resp")
                        abort = True
                        break
                    else:
                        result.img_saved = True
                else:
                    rospy.loginfo("%s: New viewpoint is worse than previous one!" % self._action_name)
                    result.img_saved = False

            rospy.loginfo("%s: Computing visibility values." % self._action_name)
            compute_vis_vals_resp = call_compute_vis_values_srv(cur_poses, goal.pmap_to_octomap_mode)
            if not compute_vis_vals_resp:
                rospy.logerr("%s: Error while calling compute_vis_vals srv." % self._action_name)
                abort = True
                break
            if sum(compute_vis_vals_resp.vis_values) == 0:
                rospy.loginfo("%s: Result vis values are all zero." % self._action_name)
                abort = True
                break

            max_val = max(compute_vis_vals_resp.vis_values)
            max_index = [i for i, j in enumerate(compute_vis_vals_resp.vis_values) if j == max_val][0]
            max_pose = cur_poses[max_index]
            rospy.loginfo("%s: Current max vis_value = %f" % (self._action_name, max_val))
            call_compute_vis_value_srv(max_pose, goal.pmap_to_octomap_mode)  # for debugging

            if prev_max_pose == max_pose:
                rospy.loginfo("%s: Success!" % self._action_name)
                break
            else:
                prev_max_pose = max_pose
                # publish feedback
                feedback.poses = cur_poses
                feedback.vis_values = compute_vis_vals_resp.vis_values
                self._as.publish_feedback(feedback)

            move_base_goal = MoveBaseGoal()
            move_base_goal.target_pose.header.stamp = rospy.get_rostime()
            move_base_goal.target_pose.header.frame_id = "map"
            move_base_goal.target_pose.pose.position.x = max_pose.position.x
            move_base_goal.target_pose.pose.position.y = max_pose.position.y
            move_base_goal.target_pose.pose.position.z = 0.0
            move_base_goal.target_pose.pose.orientation = max_pose.orientation
            move_base_ac.send_goal(move_base_goal)
            move_base_ac.wait_for_result()

            cur_iter += 1

        # loop reached max_iter
        if cur_iter == max_iter and not abort:
            abort = True

        if preempt:
            self._as.set_preempted(result)
        elif abort:
            self._as.set_aborted(result)
        else:
            self._as.set_succeeded(result)

if __name__ == "__main__":
    rospy.init_node("find_viewpoint")
    FindViewpointNode(rospy.get_name())
    rospy.spin()
